// RobotBuilder Version: 4.0
//
// This file was generated by RobotBuilder. It contains sections of
// code that are automatically generated and assigned by robotbuilder.
// These sections will be updated in the future when you export to
// C++ from RobotBuilder. Do not put any code or make any change in
// the blocks indicating autogenerated code or it will be lost on an
// update. Deleting the comments indicating the section will prevent
// it from being updated in the future.

// ROBOTBUILDER TYPE: Subsystem.

// BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=INCLUDES
#include "subsystems/SwerveDrive.h"
// #include "subsystems/SwervePod.h"
#include <frc/smartdashboard/SmartDashboard.h>
// #include <frc/kinematics/SwerveDriveKinematics.h>

// END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=INCLUDES

using namespace rev;
using namespace frc;



SwerveDrive::SwerveDrive() {

    m_leftFrontTopMotor = new CANSparkMax(1, CANSparkMaxLowLevel::MotorType::kBrushless);
    m_leftFrontBottomMotor = new CANSparkMax(2, CANSparkMaxLowLevel::MotorType::kBrushless);
    m_rightFrontTopMotor = new CANSparkMax(3, CANSparkMaxLowLevel::MotorType::kBrushless);
    m_rightFrontBottomMotor = new CANSparkMax(4, CANSparkMaxLowLevel::MotorType::kBrushless);
    m_leftBackTopMotor = new CANSparkMax(5, CANSparkMaxLowLevel::MotorType::kBrushless);
    m_leftBackBottomMotor = new CANSparkMax(6, CANSparkMaxLowLevel::MotorType::kBrushless);
    m_rightBackTopMotor = new CANSparkMax(7, CANSparkMaxLowLevel::MotorType::kBrushless);
    m_rightBackBottomMotor = new CANSparkMax(8, CANSparkMaxLowLevel::MotorType::kBrushless);

    m_frontPod = new SwervePod(m_leftFrontTopMotor, m_leftFrontBottomMotor, 0);
    // m_frontRightPod = new SwervePod(m_rightFrontTopMotor, m_rightFrontBottomMotor);
    m_backLeftPod = new SwervePod(m_leftBackTopMotor, m_leftBackBottomMotor, 1);
    m_backRightPod = new SwervePod(m_rightBackTopMotor, m_rightBackBottomMotor, 2);

    // Locations for the swerve drive modules relative to the robot center.
    frc::Translation2d m_frontLocation{0.0_m, 0.381_m};
    frc::Translation2d m_backLeftLocation{-0.381_m, 0.381_m};
    frc::Translation2d m_backRightLocation{-0.381_m, -0.381_m};

    // // Creating my kinematics object using the module locations.
    m_kinematics = new SwerveDriveKinematics<3>{
        m_frontLocation, m_backLeftLocation, m_backRightLocation
    };

    // m_swerveMath = new SwerveMath(28.0, 26.0);

    SetName("SwerveDrive");
    // BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DECLARATIONS
    SetSubsystem("SwerveDrive");

    // AddChild("RightBackEncoder", &m_rightBackEncoder);
    // m_rightBackEncoder.SetDistancePerPulse(1.0);

    // AddChild("LeftBackEncoder", &m_leftBackEncoder);
    // m_leftBackEncoder.SetDistancePerPulse(1.0);

    // AddChild("RightFrontEncoder", &m_rightFrontEncoder);
    // m_rightFrontEncoder.SetDistancePerPulse(1.0);

    // AddChild("LeftFrontEncoder", &m_leftFrontEncoder);
    // m_leftFrontEncoder.SetDistancePerPulse(1.0);

// END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DECLARATIONS

}

void SwerveDrive::initialize(){
    m_frontPod->Initialize();
}

void SwerveDrive::Periodic() {
    // Put code here to be run every loop
    
}

void SwerveDrive::SimulationPeriodic() {
    // This method will be called once per scheduler run when in simulation

}

void SwerveDrive::DrivePods(double forward, double strafe, double rotation, double angle) {
    const double k_gearRatioWheelSpeed = 3.2196;
    const double k_wheelDiameterMeters = 0.0635;
    const double k_wheelCircumferenceMeters = k_wheelDiameterMeters * (double)3.141592653;
    const double k_maxMotorSpeed = 5200.0;
    // SwerveMathOutput output[4] = {0, 0, 0, 0, 0, 0, 0, 0};
    // m_swerveMath->Calculate(forward, strafe, rotation, angle, output);

    // m_frontLeftPod->Drive(output[FRONT_RIGHT].angle, output[FRONT_RIGHT].speed);
    // m_frontRightPod->Drive(output[FRONT_LEFT].angle, output[FRONT_LEFT].speed);
    // m_backLeftPod->Drive(output[BACK_RIGHT].angle, output[BACK_RIGHT].speed);
    // m_backRightPod->Drive(output[BACK_LEFT].angle, output[BACK_LEFT].speed);

    // transforming from pure joystick input into chassisspeeds
    double transform = k_wheelCircumferenceMeters * k_gearRatioWheelSpeed * k_maxMotorSpeed;

    frc::ChassisSpeeds speeds{(units::angular_velocity::radians_per_second_t)(forward*transform),
        (units::angular_velocity::radians_per_second_t)(strafe*transform),
        (units::angular_velocity::radians_per_second_t)(rotation*transform)};
    
    auto [front, backLeft, backRight] = m_kinematics->ToSwerveModuleStates(speeds);
    m_frontPod->Drive(front);
    m_backLeftPod->Drive(backLeft);
    m_backRightPod->Drive(backRight);

}

// BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=CMDPIDGETTERS

// END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=CMDPIDGETTERS


// Put methods for controlling this subsystem
// here. Call these from Commands.
