// RobotBuilder Version: 4.0
//
// This file was generated by RobotBuilder. It contains sections of
// code that are automatically generated and assigned by robotbuilder.
// These sections will be updated in the future when you export to
// C++ from RobotBuilder. Do not put any code or make any change in
// the blocks indicating autogenerated code or it will be lost on an
// update. Deleting the comments indicating the section will prevent
// it from being updated in the future.

// ROBOTBUILDER TYPE: Subsystem.

#include "subsystems/SwerveDrive.h"
#include <frc/smartdashboard/SmartDashboard.h>
#include <iostream>

using namespace rev;
using namespace frc;

/**
 * SwerveDrive implementation file
 *
 * @author 2826WaveRobotics
 */
SwerveDrive::SwerveDrive() {


    // All swerve module motors
    m_frontTopMotor = new CANSparkMax(58, CANSparkMaxLowLevel::MotorType::kBrushless);
    m_frontBottomMotor = new CANSparkMax(4, CANSparkMaxLowLevel::MotorType::kBrushless);
    m_rearTopMotor = new CANSparkMax(1, CANSparkMaxLowLevel::MotorType::kBrushless);
    m_rearBottomMotor = new CANSparkMax(2, CANSparkMaxLowLevel::MotorType::kBrushless);


    //m_leftBackTopMotor = new CANSparkMax(5, CANSparkMaxLowLevel::MotorType::kBrushless);
    //m_leftBackBottomMotor = new CANSparkMax(6, CANSparkMaxLowLevel::MotorType::kBrushless);
    //m_rightBackTopMotor = new CANSparkMax(7, CANSparkMaxLowLevel::MotorType::kBrushless);
    //m_rightBackBottomMotor = new CANSparkMax(8, CANSparkMaxLowLevel::MotorType::kBrushless);

    // Individual swerve pod instances
    m_frontPod = new SwervePod(m_frontTopMotor, m_frontBottomMotor, 0);
    m_rearPod = new SwervePod(m_rearTopMotor, m_rearBottomMotor, 1);
    //m_backLeftPod = new SwervePod(m_leftBackTopMotor, m_leftBackBottomMotor, 1);
    //m_backRightPod = new SwervePod(m_rightBackTopMotor, m_rightBackBottomMotor, 2);

    // Locations for the swerve drive modules relative to the robot center.
    frc::Translation2d m_frontLocation{0.0_m, 0.0_m};
    frc::Translation2d m_rearLocation{0.0_m, 0.0_m};

    // m_topEncoder = new SparkMaxRelativeEncoder(m_frontTopMotor->GetEncoder());
    // m_bottomEncoder = new SparkMaxRelativeEncoder(m_frontBottomMotor->GetEncoder());

    // frc::Translation2d m_backLeftLocation{-0.381_m, 0.381_m};
    // frc::Translation2d m_backRightLocation{-0.381_m, -0.381_m};

    //Creating kinematics object using the module locations.
    // m_kinematics = new SwerveDriveKinematics<3>{
    //     m_frontLocation, m_backLeftLocation, m_backRightLocation
    // };

    m_kinematics = new SwerveDriveKinematics<2>{
        m_frontLocation, m_rearLocation
    };


    SetName("SwerveDrive");
    SetSubsystem("SwerveDrive");

}

void SwerveDrive::initialize(){
    m_frontPod->Initialize();
}

void SwerveDrive::Periodic() {
    // Put code here to be run every loop
    
}

void SwerveDrive::SimulationPeriodic() {
    // This method will be called once per scheduler run when in simulation

}

//TODO: move into conversion/util file
double rpmToMps(double rpm, double wheelDiameterMeters) {
    double PI = 2 * acos(0.0);
    double k_wheelCircumferenceMeters = wheelDiameterMeters * PI;

    return rpm * k_wheelCircumferenceMeters / 60;
}

void SwerveDrive::DrivePods(double forward, double strafe, double rotation) {
    const double k_gearRatioWheelSpeed = 3.2196;
    const double k_wheelDiameterMeters = 0.0635;
    // circumference ~ 0.1994911335
    const double k_wheelCircumferenceMeters = k_wheelDiameterMeters * (double)3.141592653;
    const double k_maxMotorSpeed = 5200.0;

    // transforming from pure joystick input into chassisspeeds
    double transform = k_wheelCircumferenceMeters * k_gearRatioWheelSpeed * k_maxMotorSpeed;
     
    // frc::ChassisSpeeds speeds{(units::angular_velocity::radians_per_second_t)(forward*transform),
    //     (units::angular_velocity::radians_per_second_t)(strafe*transform),
    //     (units::angular_velocity::radians_per_second_t)(rotation*transform)};

    frc::ChassisSpeeds speeds{(units::velocity::meters_per_second_t)(forward*transform),
        (units::velocity::meters_per_second_t)(strafe*transform),
        (units::angular_velocity::radians_per_second_t)(rotation*transform)};
    
    // auto [front, backLeft, backRight] = m_kinematics->ToSwerveModuleStates(speeds);
    auto [front, rear] = m_kinematics->ToSwerveModuleStates(speeds);

    m_frontPod->Drive(front, rotation, forward);

 
    //m_frontPod->Drive(front);
    //m_rearPod->Drive(rear);

    //m_backLeftPod->Drive(backLeft);
    //m_backRightPod->Drive(backRight);

}

