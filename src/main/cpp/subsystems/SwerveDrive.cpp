// RobotBuilder Version: 4.0
//
// This file was generated by RobotBuilder. It contains sections of
// code that are automatically generated and assigned by robotbuilder.
// These sections will be updated in the future when you export to
// C++ from RobotBuilder. Do not put any code or make any change in
// the blocks indicating autogenerated code or it will be lost on an
// update. Deleting the comments indicating the section will prevent
// it from being updated in the future.

// ROBOTBUILDER TYPE: Subsystem.

#include "subsystems/SwerveDrive.h"
#include <frc/smartdashboard/SmartDashboard.h>
#include <iostream>

using namespace rev;
using namespace frc;

/**
 * SwerveDrive implementation, schyncronizing individual swerve pods
 *
 * @author 2826WaveRobotics
 */
SwerveDrive::SwerveDrive() {

    // All swerve module motors
    m_rightTopMotor = new CANSparkMax(58, CANSparkMaxLowLevel::MotorType::kBrushless);
    m_rightBottomMotor = new CANSparkMax(4, CANSparkMaxLowLevel::MotorType::kBrushless);
    m_leftTopMotor = new CANSparkMax(1, CANSparkMaxLowLevel::MotorType::kBrushless);
    m_leftBottomMotor = new CANSparkMax(2, CANSparkMaxLowLevel::MotorType::kBrushless);
    m_pointTopMotor = new CANSparkMax(45, CANSparkMaxLowLevel::MotorType::kBrushless);
    m_pointBottomMotor = new CANSparkMax(67, CANSparkMaxLowLevel::MotorType::kBrushless);

    // Individual swerve pod instances
    m_rightPod = new SwervePod(m_rightTopMotor, m_rightBottomMotor, 1.0, 90.0, 0); // 90 or 270?
    m_leftPod = new SwervePod(m_leftTopMotor, m_leftBottomMotor, 1.0, 270.0, 1);   // 90 or 270?
    m_pointPod = new SwervePod(m_pointTopMotor, m_pointBottomMotor, 1.0, 45.0, 2); // 45 or -135?
    
    // Locations for the swerve drive modules relative to the robot center.
    frc::Translation2d m_rightLocation{(units::meter_t)-0.5*robotWidth, (units::meter_t)-0.5*robotHeight};
    frc::Translation2d m_leftLocation{(units::meter_t)0.5*robotWidth, (units::meter_t)-0.5*robotHeight};
    frc::Translation2d m_pointLocation{0.0_m, (units::meter_t)0.5*robotHeight};

    // 3 pod swerve kinematics object using module locations
    m_kinematics = new SwerveDriveKinematics<3>{
        m_rightLocation, m_leftLocation, m_pointLocation
    };

    SetName("SwerveDrive");
    SetSubsystem("SwerveDrive");
}

void SwerveDrive::initialize(){
    m_rightPod->Initialize();
    m_leftPod->Initialize();
    m_pointPod->Initialize();
}

void SwerveDrive::Periodic() {
    // Put code here to be run every loop
}

void SwerveDrive::SimulationPeriodic() {
    // This method will be called once per scheduler run when in simulation
}

void SwerveDrive::DrivePods(double forward, double strafe, double rotation) {
    const double k_gearRatioWheelSpeed = 3.2196;
    const double k_wheelDiameterMeters = 0.0635;
    const double k_wheelCircumferenceMeters = k_wheelDiameterMeters * (double)3.141592653;
    const double k_maxMotorSpeed = 5200.0;

    // transforming from pure joystick input into chassisspeeds
    double transform = k_wheelCircumferenceMeters * k_gearRatioWheelSpeed * k_maxMotorSpeed;

    // represents the velocity of the robot chassis
    // ChassisSpeeds struct represents a velocity w.r.t to the robot frame of reference
    // foward is negated to flip the axis of the LX input
    frc::ChassisSpeeds speeds{(units::velocity::meters_per_second_t)(-forward*transform),
        (units::velocity::meters_per_second_t)(strafe*transform),
        (units::angular_velocity::radians_per_second_t)(rotation*transform)};
    
    // returns each pods state (speed, angle)
    auto [right, left, point] = m_kinematics->ToSwerveModuleStates(speeds);

    m_rightPod->Drive(right);
    m_leftPod->Drive(left);
    m_pointPod->Drive(point);
}
